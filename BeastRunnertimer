-- RunnerBottomLeftSynced.local.lua
-- LocalScript -> Coloque em StarterPlayerScripts
-- O que faz (atualizado conforme solicitado):
--  - menu minimalista acionado com L e toggle "Contador de tempo (runner)"
--  - labels grandes e visíveis acima da cabeça dos outros jogadores (AlwaysOnTop, MaxDistance alto)
--  - indicador minimalista e sem fundo no canto inferior esquerdo, SIMÉTRICO e sincronizado com o texto exibido nas labels de cabeça
--  - ambos (head label e bottom-left) usam a MESMA formatação: arredonda numberValue * 100 e mostra como "NN%"
--  - atualização reativa (NumberValue.Changed) e limpeza ao desativar / fim de partida
-- Cole esse LocalScript em StarterPlayerScripts (LocalScript).

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Root ScreenGui (alto DisplayOrder para evitar sobreposição)
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "RunnerBottomLeftSyncedGUI"
screenGui.ResetOnSpawn = false
screenGui.DisplayOrder = 5000
screenGui.IgnoreGuiInset = true
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = PlayerGui

-- helpers
local function makeCorner(parent, radius)
    local c = Instance.new("UICorner")
    c.CornerRadius = UDim.new(0, radius or 8)
    c.Parent = parent
    return c
end
local function makeStroke(parent, thickness, transparency, color)
    local s = Instance.new("UIStroke")
    s.Thickness = thickness or 1.6
    s.Transparency = (transparency ~= nil) and transparency or 0.45
    s.Color = color or Color3.fromRGB(0,0,0)
    s.Parent = parent
    return s
end
local function tween(inst, props, info)
    info = info or TweenInfo.new(0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    TweenService:Create(inst, info, props):Play()
end

-- SAME FORMAT AS HEAD LABELS (synchronization)
local function formatHeadText(value)
    -- replicates original behaviour: round(value * 100) .. "%"
    if type(value) ~= "number" then return "0%" end
    return tostring(math.round(value * 100)) .. "%"
end

-- Minimal menu / hint (L)
local hint = Instance.new("TextLabel")
hint.Name = "Hint"
hint.AnchorPoint = Vector2.new(0.5, 1)
hint.Size = UDim2.new(0, 220, 0, 26)
hint.Position = UDim2.new(0.5, 0, 1, -18)
hint.BackgroundTransparency = 1
hint.Text = 'Pressione "L" para abrir o menu'
hint.Font = Enum.Font.SourceSansSemibold
hint.TextSize = 14
hint.TextColor3 = Color3.fromRGB(240,240,240)
hint.TextScaled = true
hint.TextXAlignment = Enum.TextXAlignment.Center
hint.ZIndex = 60
hint.Parent = screenGui

local menu = Instance.new("Frame")
menu.Name = "RunnerMenu"
menu.AnchorPoint = Vector2.new(0.5, 0.5)
menu.Size = UDim2.new(0, 340, 0, 120)
menu.Position = UDim2.new(0.5, 0, 0.45, 0)
menu.BackgroundColor3 = Color3.fromRGB(22,22,24)
menu.BorderSizePixel = 0
menu.Visible = false
menu.ZIndex = 70
menu.Parent = screenGui
makeCorner(menu, 12)

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -24, 0, 28)
title.Position = UDim2.new(0, 12, 0, 10)
title.BackgroundTransparency = 1
title.Font = Enum.Font.SourceSansBold
title.TextSize = 18
title.TextColor3 = Color3.fromRGB(245,245,245)
title.Text = "Runner"
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = menu

local subtitle = Instance.new("TextLabel")
subtitle.Size = UDim2.new(1, -24, 0, 16)
subtitle.Position = UDim2.new(0, 12, 0, 36)
subtitle.BackgroundTransparency = 1
subtitle.Font = Enum.Font.SourceSans
subtitle.TextSize = 12
subtitle.TextColor3 = Color3.fromRGB(170,170,170)
subtitle.Text = "Controles de exibição"
subtitle.TextXAlignment = Enum.TextXAlignment.Left
subtitle.Parent = menu

local row = Instance.new("Frame")
row.Size = UDim2.new(1, -24, 0, 48)
row.Position = UDim2.new(0, 12, 0, 56)
row.BackgroundTransparency = 1
row.Parent = menu

local label = Instance.new("TextLabel")
label.Size = UDim2.new(0.7, 0, 1, 0)
label.BackgroundTransparency = 1
label.Font = Enum.Font.SourceSans
label.TextSize = 14
label.Text = "Contador de tempo (runner)"
label.TextColor3 = Color3.fromRGB(235,235,235)
label.TextXAlignment = Enum.TextXAlignment.Left
label.Parent = row

local toggleBtn = Instance.new("TextButton")
toggleBtn.Size = UDim2.new(0.3, 0, 0.72, 0)
toggleBtn.Position = UDim2.new(0.7, 0, 0.14, 0)
toggleBtn.BackgroundColor3 = Color3.fromRGB(180, 0, 0)
toggleBtn.BorderSizePixel = 0
toggleBtn.Font = Enum.Font.SourceSansBold
toggleBtn.TextSize = 14
toggleBtn.Text = "OFF"
toggleBtn.TextColor3 = Color3.fromRGB(255,255,255)
toggleBtn.Parent = row
makeCorner(toggleBtn, 9)

-- ========== Head labels (for other players) ==========
local function createHeadLabel(player)
    if not player or player == LocalPlayer then return nil end
    if not player.Character then return nil end
    local char = player.Character
    local hrp = char:FindFirstChild("HumanoidRootPart") or char:WaitForChild("HumanoidRootPart", 5)
    if not hrp then return nil end

    local bb = hrp:FindFirstChild("BeastPowerBillboard")
    if not bb then
        bb = Instance.new("BillboardGui")
        bb.Name = "BeastPowerBillboard"
        bb.Parent = hrp
        bb.Size = UDim2.new(3.2, 0, 1.8, 0)
        bb.StudsOffset = Vector3.new(0, 5.2, 0)
        bb.AlwaysOnTop = true
        bb.LightInfluence = 0
        bb.MaxDistance = 1e6
    end

    local txt = bb:FindFirstChild("BeastPowerLabel")
    if not txt then
        txt = Instance.new("TextLabel")
        txt.Name = "BeastPowerLabel"
        txt.BackgroundTransparency = 1
        txt.Size = UDim2.new(1,0,1,0)
        txt.Font = Enum.Font.SourceSansBold
        txt.TextScaled = true
        txt.TextWrapped = true
        txt.TextColor3 = Color3.fromRGB(255,255,255)
        txt.Text = ""
        txt.TextXAlignment = Enum.TextXAlignment.Center
        txt.TextYAlignment = Enum.TextYAlignment.Center
        txt.Parent = bb
        makeStroke(txt, 2, 0.45, Color3.fromRGB(0,0,0))
    end

    return txt
end

-- per-player reactive state
local state = {
    perPlayer = {}, -- [player] = { charConn, beastAdded, beastRemoved, beastChildConn, numberConn }
    playersConn = nil,
    runnerEnabled = false
}

local function percentText(val)
    return formatHeadText(val)
end

local function connectReactiveForCharacter(player, character)
    if not player or not character then return end
    state.perPlayer[player] = state.perPlayer[player] or {}
    local entry = state.perPlayer[player]

    if entry.numberConn then entry.numberConn:Disconnect() entry.numberConn = nil end
    if entry.beastChildConn then entry.beastChildConn:Disconnect() entry.beastChildConn = nil end
    if entry.beastAdded then entry.beastAdded:Disconnect() entry.beastAdded = nil end
    if entry.beastRemoved then entry.beastRemoved:Disconnect() entry.beastRemoved = nil end

    local function tryConnect()
        if not character or not character.Parent then return end
        local beast = character:FindFirstChild("BeastPowers")
        local label = createHeadLabel(player)
        if beast then
            local nv = beast:FindFirstChildOfClass("NumberValue")
            if nv then
                if label then label.Text = percentText(nv.Value) end
                entry.numberConn = nv.Changed:Connect(function()
                    if label then label.Text = percentText(nv.Value) end
                end)
            else
                if label then label.Text = "" end
                entry.beastChildConn = beast.ChildAdded:Connect(function(child)
                    if child:IsA("NumberValue") then
                        task.wait(0.02)
                        tryConnect()
                    end
                end)
            end
        else
            if label then label.Text = "" end
        end
    end

    entry.beastAdded = character.ChildAdded:Connect(function(child)
        if child.Name == "BeastPowers" then
            task.wait(0.04)
            tryConnect()
        end
    end)
    entry.beastRemoved = character.ChildRemoved:Connect(function(child)
        if child.Name == "BeastPowers" then
            if entry.numberConn then entry.numberConn:Disconnect() entry.numberConn = nil end
            if entry.beastChildConn then entry.beastChildConn:Disconnect() entry.beastChildConn = nil end
            local label = createHeadLabel(player)
            if label then label.Text = "" end
        end
    end)

    tryConnect()
end

local function attachPlayers()
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer then
            state.perPlayer[pl] = state.perPlayer[pl] or {}
            if state.perPlayer[pl].charConn then
                state.perPlayer[pl].charConn:Disconnect()
                state.perPlayer[pl].charConn = nil
            end
            state.perPlayer[pl].charConn = pl.CharacterAdded:Connect(function(c)
                task.wait(0.35)
                createHeadLabel(pl)
                connectReactiveForCharacter(pl, c)
            end)
            if pl.Character then
                createHeadLabel(pl)
                connectReactiveForCharacter(pl, pl.Character)
            end
        end
    end
end

local function cleanupHeads()
    for pl, entry in pairs(state.perPlayer) do
        if entry.charConn then entry.charConn:Disconnect() end
        if entry.numberConn then entry.numberConn:Disconnect() end
        if entry.beastChildConn then entry.beastChildConn:Disconnect() end
        state.perPlayer[pl] = nil
    end
    if state.playersConn then state.playersConn:Disconnect() state.playersConn = nil end

    for _, pl in ipairs(Players:GetPlayers()) do
        if pl.Character then
            local hrp = pl.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local bb = hrp:FindFirstChild("BeastPowerBillboard")
                if bb then bb:Destroy() end
            end
        end
    end
end

-- ========== Bottom-left synced label ==========
local bottomContainer = Instance.new("Frame")
bottomContainer.Name = "BottomLeftContainer"
bottomContainer.AnchorPoint = Vector2.new(0, 1)
bottomContainer.Size = UDim2.new(0, 220, 0, 48)
bottomContainer.Position = UDim2.new(0, 12, 1, -12) -- bottom-left inset
bottomContainer.BackgroundTransparency = 1
bottomContainer.BorderSizePixel = 0
bottomContainer.ZIndex = 500
bottomContainer.Parent = screenGui

local bottomTitle = Instance.new("TextLabel")
bottomTitle.Name = "BottomTitle"
bottomTitle.Size = UDim2.new(1, 0, 0, 18)
bottomTitle.Position = UDim2.new(0, 0, 0, 0)
bottomTitle.BackgroundTransparency = 1
bottomTitle.Font = Enum.Font.SourceSansSemibold
bottomTitle.TextSize = 14
bottomTitle.TextScaled = true
bottomTitle.Text = "BeastPower"
bottomTitle.TextColor3 = Color3.fromRGB(245,245,245)
bottomTitle.TextXAlignment = Enum.TextXAlignment.Left
bottomTitle.TextYAlignment = Enum.TextYAlignment.Center
bottomTitle.Parent = bottomContainer
makeStroke(bottomTitle, 1.2, 0.45, Color3.fromRGB(0,0,0))

local bottomValue = Instance.new("TextLabel")
bottomValue.Name = "BottomValue"
bottomValue.Size = UDim2.new(1, 0, 0, 30)
bottomValue.Position = UDim2.new(0, 0, 0, 18)
bottomValue.BackgroundTransparency = 1
bottomValue.Font = Enum.Font.SourceSansBold
bottomValue.TextSize = 20
bottomValue.TextScaled = true
bottomValue.Text = "0%"
bottomValue.TextColor3 = Color3.fromRGB(255,255,255)
bottomValue.TextXAlignment = Enum.TextXAlignment.Left
bottomValue.TextYAlignment = Enum.TextYAlignment.Center
bottomValue.Parent = bottomContainer
makeStroke(bottomValue, 2, 0.45, Color3.fromRGB(0,0,0))

bottomContainer.Visible = false -- shown when runner enabled (and when local NV present or default)

-- find local NumberValue in Character.BeastPowers (common names) or first NumberValue
local function findLocalNumberValue()
    local char = LocalPlayer.Character
    if not char then return nil end
    local beast = char:FindFirstChild("BeastPowers")
    if not beast then return nil end
    local preferred = {"Cooldown", "BeastCooldown", "CooldownTime", "Power", "Value", "BeastValue"}
    for _, name in ipairs(preferred) do
        local obj = beast:FindFirstChild(name)
        if obj and obj:IsA("NumberValue") then return obj end
    end
    return beast:FindFirstChildOfClass("NumberValue")
end

-- Manage connection for local NumberValue: keep bottomValue in sync with formatting used for head labels
local localConn = nil
local localBeastChildConn = nil
local localBeastRemovedConn = nil
local pollingTask = nil
local pollingStop = false

local function stopPolling()
    pollingStop = true
    pollingTask = nil
end

local function startPollingForLocalNV()
    if pollingTask then return end
    pollingStop = false
    pollingTask = task.spawn(function()
        while not pollingStop and state.runnerEnabled do
            local nv = findLocalNumberValue()
            if nv then
                -- found -> connect properly
                if pollingTask then stopPolling() end
                -- small delay to let other handlers run
                task.wait(0.02)
                -- call connectLocal now (defined below)
                if state.runnerEnabled then
                    -- connectLocal will show the container
                    connectLocal()
                end
                return
            else
                -- show container with default 0% while waiting (so it is visible)
                bottomValue.Text = "0%"
                bottomContainer.Visible = true
                task.wait(0.5)
            end
        end
    end)
end

function connectLocal()
    -- cleanup previous
    if localConn then localConn:Disconnect() localConn = nil end
    if localBeastChildConn then localBeastChildConn:Disconnect() localBeastChildConn = nil end
    if localBeastRemovedConn then localBeastRemovedConn:Disconnect() localBeastRemovedConn = nil end
    stopPolling()
    bottomContainer.Visible = false

    local char = LocalPlayer.Character
    if not char then
        -- wait/poll for character -> show default
        startPollingForLocalNV()
        return
    end

    local beast = char:FindFirstChild("BeastPowers")
    if not beast then
        startPollingForLocalNV()
        -- listen for BeastPowers creation
        localBeastChildConn = char.ChildAdded:Connect(function(child)
            if child.Name == "BeastPowers" then
                task.wait(0.02)
                connectLocal()
            end
        end)
        return
    end

    local nv = findLocalNumberValue()
    if not nv then
        -- poll for NV inside BeastPowers
        startPollingForLocalNV()
        localBeastChildConn = beast.ChildAdded:Connect(function(child)
            if child:IsA("NumberValue") then
                task.wait(0.02)
                connectLocal()
            end
        end)
        -- hide on beast removed
        localBeastRemovedConn = char.ChildRemoved:Connect(function(child)
            if child == beast then
                bottomContainer.Visible = false
            end
        end)
        return
    end

    -- found NV: show and connect
    bottomContainer.Visible = true
    bottomValue.Text = formatHeadText(nv.Value)

    localConn = nv.Changed:Connect(function()
        if nv.Parent then
            bottomValue.Text = formatHeadText(nv.Value)
        else
            bottomValue.Text = "0%"
        end
    end)

    localBeastRemovedConn = char.ChildRemoved:Connect(function(child)
        if child == beast then
            if localConn then localConn:Disconnect() localConn = nil end
            bottomContainer.Visible = false
        end
    end)
end

-- find common BoolValue for match state (to hide UI on match end)
local function findMatchBool()
    local containers = {workspace, game:GetService("ReplicatedStorage"), game:GetService("ServerStorage")}
    local names = {"MatchInProgress", "MatchActive", "RoundActive", "MatchFinished", "GameActive", "GameFinished", "RoundRunning"}
    for _, container in ipairs(containers) do
        if container then
            for _, name in ipairs(names) do
                local found = container:FindFirstChild(name, true)
                if found and found:IsA("BoolValue") then
                    return found
                end
            end
        end
    end
    return nil
end

local matchObj = findMatchBool()
local matchConn = nil
local function onMatchChanged()
    if not matchObj then return end
    if matchObj.Value == false then
        -- match finished: hide bottom and destroy head labels
        bottomContainer.Visible = false
        cleanupHeads()
    else
        -- match active: reconnect local
        if state.runnerEnabled then connectLocal() end
    end
end
if matchObj then
    matchConn = matchObj.Changed:Connect(onMatchChanged)
    onMatchChanged()
end

-- Enable / disable runner and cleanup
local function enableRunner()
    if state.runnerEnabled then return end
    state.runnerEnabled = true
    toggleBtn.BackgroundColor3 = Color3.fromRGB(0,160,90)
    toggleBtn.Text = "ON"

    -- attach players
    state.playersConn = Players.PlayerAdded:Connect(function(pl)
        task.wait(0.25)
        if pl ~= LocalPlayer then
            state.perPlayer[pl] = state.perPlayer[pl] or {}
            state.perPlayer[pl].charConn = pl.CharacterAdded:Connect(function(c)
                task.wait(0.35)
                createHeadLabel(pl)
                connectReactiveForCharacter(pl, c)
            end)
            if pl.Character then
                createHeadLabel(pl)
                connectReactiveForCharacter(pl, pl.Character)
            end
        end
    end)
    attachPlayers()

    -- connect local bottom label (synchronized)
    connectLocal()
end

local function disableRunner()
    if not state.runnerEnabled then return end
    state.runnerEnabled = false
    toggleBtn.BackgroundColor3 = Color3.fromRGB(170,0,0)
    toggleBtn.Text = "OFF"

    -- cleanup players
    for pl, entry in pairs(state.perPlayer) do
        if entry.charConn then entry.charConn:Disconnect() end
        if entry.numberConn then entry.numberConn:Disconnect() end
        if entry.beastChildConn then entry.beastChildConn:Disconnect() end
        state.perPlayer[pl] = nil
    end
    if state.playersConn then state.playersConn:Disconnect() state.playersConn = nil end
    cleanupHeads()

    -- cleanup local
    if localConn then localConn:Disconnect() localConn = nil end
    if localBeastChildConn then localBeastChildConn:Disconnect() localBeastChildConn = nil end
    if localBeastRemovedConn then localBeastRemovedConn:Disconnect() localBeastRemovedConn = nil end
    stopPolling()
    bottomContainer.Visible = false
end

toggleBtn.MouseButton1Click:Connect(function()
    if state.runnerEnabled then disableRunner() else enableRunner() end
end)

-- Toggle menu with L
local menuVisible = false
UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.L then
        menuVisible = not menuVisible
        if menuVisible then
            menu.Visible = true
            menu.Position = UDim2.new(0.5, 0, 0.35, 0)
            menu.BackgroundTransparency = 1
            tween(menu, {Position = UDim2.new(0.5, 0, 0.45, 0), BackgroundTransparency = 0}, TweenInfo.new(0.14))
        else
            tween(menu, {Position = UDim2.new(0.5, 0, 0.38, 0), BackgroundTransparency = 1}, TweenInfo.new(0.12))
            task.delay(0.12, function() if menu then menu.Visible = false end end)
        end
    end
end)

-- hint animation (5s)
task.spawn(function()
    task.wait(0.12)
    hint.TextTransparency = 1
    tween(hint, {TextTransparency = 0}, TweenInfo.new(0.12))
    task.wait(5)
    tween(hint, {TextTransparency = 1}, TweenInfo.new(0.12))
    task.delay(0.12, function() if hint and hint.Parent then hint:Destroy() end end)
end)

-- reconnect local on respawn while runner enabled
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.18)
    if state.runnerEnabled then
        connectLocal()
    end
end)

-- initial state: hidden
bottomContainer.Visible = false

-- End of script
